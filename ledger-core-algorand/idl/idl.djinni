@import "ledger-core/amount.djinni"

@import "callback.djinni"
@import "configuration.djinni"

AlgorandConfigurationDefaults = record {
    # TODO Switch to mainnet at some point
    const ALGORAND_API_ENDPOINT: string = "https://testnet-algorand.api.purestake.io/ps1/v1/";
    const ALGORAND_API_TOKEN: string = "VjmqAOS1jd2GEvc4Hy9RB6CW48YCRuG74bs22kfI";

    # TODO Find an observer endpoint
    const ALGORAND_OBSERVER_WS_ENDPOINT: string = "";
}

AlgorandNetworkParameters = record {
    # Name of the network
    genesisID: string;
    # Hash of the network
    genesisHash: string;
}

AlgorandOperationType = enum {
    PAYMENT;
    ACCOUNT_CLOSE;
    ACCOUNT_REGISTER_ONLINE;
    ACCOUNT_REGISTER_OFFLINE;
    ASSET_CREATE;
    ASSET_RECONFIGURE;
    ASSET_DESTROY;
    ASSET_OPT_IN;
    ASSET_OPT_OUT;
    ASSET_TRANSFER;
    ASSET_REVOKE;
    ASSET_FREEZE;
    UNSUPPORTED;
}

AlgorandAssetParams = record {
    # The unique asset identifier
    assetId: optional<string>;
    # The name of this asset, as supplied by the creator
    assetName: optional<string>;
    # The name of a unit of this asset, as supplied by the creator
    unitName: optional<string>;
    # A URL where more information about the asset can be retrieved
    url: optional<string>;
    # Specifies whether holdings in this asset are frozen by default
    defaultFrozen: optional<bool>;

    # The total number of units of this asset
    total: optional<string>;
    # The number of digits to use after the decimal point when displaying this asset
    decimals: optional<i32>;

    # The address that created this asset.
    creatorAddress: optional<string>;
    # The address used to manage the keys of this asset and to destroy it
    managerAddress: optional<string>;
    # The address used to freeze holdings of this asset. If empty, freezing is not permitted.
    freezeAddress: optional<string>;
    # The address used to clawback holdings of this asset. If empty, clawback is not permitted.
    clawbackAddress: optional<string>;
    # The address holding reserve (non-minted) units of this asset
    reserveAddress: optional<string>;
    # Some unspecified asset metadata (32 bytes in Base64)
    metadataHash: optional<string>;
}

AlgorandAssetAmount = record {
    # The address that created the asset
    creatorAddress: string;
    # The amount of asset
    amount: string;
    # Whether this amount is frozen
    frozen: bool;
}

AlgorandPaymentInfo = record {
    # The recipient's address
    recipientAddress: string;
    # The amount of MicroAlgos being transferred
    amount: string;
    # The address to send all remaining funds before closing the account
    closeAddress: optional<string>;

    # The amount sent to CloseRemainderTo, for committed transaction
    # FIXME what is this for?
    closeAmount: optional<string>;
    # The amount of pending rewards applied to the CloseRemainderTo account as part of this transaction
    # FIXME what is this for?
    closeRewards: optional<string>;
    # The amount of pending rewards applied to the recipient account as part of this transaction
    # FIXME what is this for?
    recipientRewards: optional<string>;
}

AlgorandParticipationInfo = record {
    # The root participation public key (if any) currently registered for this round
    rootPublicKey: string;
    # The selection (VRF) public key (if any) currently registered for this round
    vrfPublicKey: string;

    # The number of subkeys for each batch of participation keys
    voteKeyDilution: string;
    # The first round for which this participation is valid
    voteFirstRound: string;
    # The last round for which this participation is valid
    voteLastRound: string;
}

AlgorandAssetConfigurationInfo = record {
    # The unique asset ID. Required to re-configure or destroy the asset, set to zero on asset creation.
    assetId: optional<string>;
    # The asset configuration options. Empty when destroying the asset.
    assetParams: optional<AlgorandAssetParams>;
}

AlgorandAssetTransferInfo = record {
    # The unique asset ID. Required to re-configure or destroy the asset, set to zero on asset creation.
    assetId: string;
    # The amount of asset being transferred
    amount: optional<string>;
    # The recipient's address
    recipientAddress: string;
    # The address to send all remaining funds before closing the account
    closeAddress: optional<string>;
    # Sender account on which clawback is used
    clawedBackAddress: optional<string>;
}

AlgorandAssetFreezeInfo = record {
    # The unique ID of the asset being (un)frozen
    assetId: string;
    # The account whose asset is being (un)frozen
    frozenAddress: string;
    # The new freeze status
    frozen: bool;
}

AlgorandTransaction = interface +c {
    const getId(): string;
    const getType(): string;
    const getSender(): string;
    const getFee(): Amount;
    const getNote(): string;
    const getRound(): string;

    setSender(sender: string);
    setFee(fee: Amount);
    setNote(note: string);

    setPaymentInfo(info: AlgorandPaymentInfo);
    const getPaymentInfo(): AlgorandPaymentInfo;

    setParticipationInfo(info: AlgorandParticipationInfo);
    const getParticipationInfo(): AlgorandParticipationInfo;

    setAssetConfigurationInfo(info: AlgorandAssetConfigurationInfo);
    const getAssetConfigurationInfo(): AlgorandAssetConfigurationInfo;

    setAssetTransferInfo(info: AlgorandAssetTransferInfo);
    const getAssetTransferInfo(): AlgorandAssetTransferInfo;

    setAssetFreezeInfo(info: AlgorandAssetFreezeInfo);
    const getAssetFreezeInfo(): AlgorandAssetFreezeInfo;

    # Serialize the transaction in MsgPack format
    const serialize(): binary;

    setSignature(signature: binary);
}

AlgorandOperation = interface +c {
    const getOperationType(): AlgorandOperationType;
    const getTransaction(): AlgorandTransaction;
}

AlgorandAccount = interface +c {
    getAssets(callback: ListCallback<AlgorandAssetParams>);
    getCreatedAssets(callback: ListCallback<AlgorandAssetParams>);

    getAssetBalance(assetId: string, callback: Callback<AlgorandAssetAmount>);

    getPendingReward(callback: Callback<Amount>);

    getFeeEstimate(transaction: AlgorandTransaction, callback: Callback<Amount>);

    broadcastTransaction(transaction: AlgorandTransaction);
}

AlgorandWallet = interface +c {

}
